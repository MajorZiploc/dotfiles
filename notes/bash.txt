( ) (for subshell) can be used to basically join stdout and the pipe will redirect all the output of all commands in the ( )
{ } (for current shell)
(ls; ls) | less # content of directory listed twice in list
{ ls ; ls; } | less # content of directory listed twice in list -- SPACES AND SEMI COLONS ARE IMPORTANT IN THIS!

ex: ls -a - ~
-	End of options flag. All other arguments are positional parameters.

--	Unset positional parameters. If arguments given (-- arg1 arg2), positional parameters set to arguments.

less:
while in less. use shift+F to auto refresh the file. To toggle it off, use Ctrl+C

Parameter expansion:
: means to count empty string as unset
using param@/param* or param[@]/param[*] can change the param expansion behavior

# Conditionals:
# assign param to default if its null
${param:=default}
# use default if param null
${param:-default}
# returns non zero and uses error expression if param is null
${param:?error}
# use alternate if param is nonnull
${param:+alternate}

# Extraction:
# returns the rest of param after the offset
${param:offset}
# returns chars of length size after the offset for param
${param:offset:length}

# Removal from left edge:
${param#glob_pattern} # non greedy
${param##glob_pattern} # greedy
# Removal from right edge:
${param%glob_pattern} # non greedy
${param%%glob_pattern} # greedy

# Indirect Expansion: like pointers
${!param}
# List variables that match a glob pattern
${!pa@}
# List keys in an array (usually indices)
${!name[@]}
# get length of variable or array
${#param} || ${#param[@]}

# search for variables declared
set | egrep "<variable_pattern>"

# Substition:
${param/search_glob_pattern/replacement_text} # non greedy
${param//search_glob_pattern/replacement_text} # greedy
# Substition at left edge:
${param/#search_glob_pattern/replacement_text} # non greedy
# Substition at right edge:
${param/%search_glob_pattern/replacement_text} # non greedy

# Arrays:
# init array with elements
array=(zero one "two three")
# add an element to an array
array+=("four and beyound")
# replace space with underscore in array elements
array=("${array[@]// /_}")
# recreate array with elements from index 2 to 4
array=("${array[@]:2:3}")
# remove the first 2 arguments
set -- "${@:3}"

# Interactive search up history for command
<CTRL>-R
# Run last command in history that starts with string
!string
# Puts last command in history that starts with string as last entry in history
!string:p

# Special parameters

# argument list
$@ or $* -- act different when in quotes. $* uses first IFS char for separation
# number of elements in argument list
$#
# shell interactive flags
$-
# shell that is currently being used
$0
# process id
$$
# process id of most recent job that occurred
$!

glob notes:
  For all nonhidden files/folders in current directory non-recursive, use -d '*'
  For all hidden files/folders in current directory non-recursive, use -d '.[^.]*'
  For all hidden and nonhidden files/folders in current directory non-recursive, use -d '* .[^.]*'

# copy contents of source to existing dir dest, including hidden stuff
# cp -a /source/. /dest/

Extra snippets:
pwsh -ExecutionPolicy [Bypass | Unrestricted | RemoteSigned| AllSigned | Default | Undefined | Restricted] -File '/path/to/script.ps1 -Flag arg'
pwsh -ExecutionPolicy [Bypass | Unrestricted | RemoteSigned| AllSigned | Default | Undefined | Restricted] -Command "& {Write-Host 'hi'}"
perl -ne 'print unless $seen{$_}++' # unique without sorting

# alias graveyard:
alias dir='ls --format=vertical'
alias vdir='ls --format=long'
  # under color guard
  alias dir='ls --color=auto --format=vertical'
  alias vdir='ls --color=auto --format=long'

# Default to human readable figures
alias df_h='df -h'
alias du_h='du -h'
alias curl_follow_redirects='curl -Lks'
alias curl_follow_redirects_ignore_security_exceptions='curl -0Lks'

alias kill_port='npx kill-port'

alias rg_nh='rg --no-heading'

# function graveyard:

function hf {
  # show most commonly used commands based on frequency
  # $1: optional pos num to show last n entries
  local n="$1";
  [[ -z "$n" ]] && { n=25; }
  history | awk '{a[$2]++}END{for(i in a){print a[i] " " i}}' | sort -n | tail -n "$n";
}

function ide1() {
  # splits the window into 2 panes
  tmux split-window -v -p 30;
}

function ide2() {
  # splits the window into 3 panes
  tmux split-window -v -p 30;
  tmux split-window -h -p 55;
}

function ide3() {
  # splits the window into 4 panes
  tmux split-window -v -p 30;
  tmux split-window -h -p 66;
  tmux split-window -h -p 50;
}

function show_find_full_paths() {
  # displays the full path names of $1 (the directory)
  # $1: optional directory. Defaults to .
  local dir="$1";
  dir=${dir:="."};
  find "$dir" -exec readlink -f "{}" \;
}

function set_power_set_experimental {
  # EXPERIMENTAL!
  # returns a set that contains all subsets of the set
  local set=$1;
  perl -le '
  sub powset {
   return [[]] unless @_;
   my $head = shift;
   my $list = &powset;
   [@$list, map { [$head, @$_] } @$list]
  }
  chomp(my @e = <>);
  for $p (@{powset(@e)}) {
   print @$p;
  }' $set
}

function set_cardesian_product_experimental {
  # EXPERIMENTAL!
  # returns a set that contains all possible pairs of elements from one set and the other
  # $1 x $2
  local set1=$1;
  local set2=$2;
  while read a; do while read b; do echo "$a, $b"; done < $set1; done < $set2;
}

FROM WINDOWS GIT BASH: 
################################## Construct PATH variable ##################################

#winpath=$(echo $MSYS2_WINPATH | tr ";" "\n" | sed -e 's/\\/\\\\/g' | xargs -I {} cygpath -u {})
#unixpath=''

# Set delimiter to new line
#IFS=$'\n'

#for pth in $winpath; do unixpath+=$(echo $pth)":"; done

#export PATH=$(echo $PATH:$unixpath | sed -e 's/:$//g')
#unset IFS
#unset unixpath
#unset winpath

################################# Constructed PATH variable #################################

