( ) (for subshell) can be used to basically join stdout and the pipe will redirect all the output of all commands in the ( )
{ } (for current shell)
(ls; ls) | less # content of directory listed twice in list
{ ls ; ls; } | less # content of directory listed twice in list -- SPACES AND SEMI COLONS ARE IMPORTANT IN THIS!

ex: ls -a - ~
-	End of options flag. All other arguments are positional parameters.

--	Unset positional parameters. If arguments given (-- arg1 arg2), positional parameters set to arguments.

less:
while in less. use shift+F to auto refresh the file. To toggle it off, use Ctrl+C

Parameter expansion:
: means to count empty string as unset
using param@/param* or param[@]/param[*] can change the param expansion behavior

# Conditionals:
# assign param to default if its null
${param:=default}
# use default if param null
${param:-default}
# returns non zero and uses error expression if param is null
${param:?error}
# use alternate if param is nonnull
${param:+alternate}

# Extraction:
# returns the rest of param after the offset
${param:offset}
# returns chars of length size after the offset for param
${param:offset:length}

# Removal from left edge:
${param#glob_pattern} # non greedy
${param##glob_pattern} # greedy
# Removal from right edge:
${param%glob_pattern} # non greedy
${param%%glob_pattern} # greedy

# Indirect Expansion: like pointers
${!param}
# List variables that match a glob pattern
${!pa@}
# List keys in an array (usually indices)
${!name[@]}
# get length of variable or array
${#param} || ${#param[@]}

# Substition:
${param/search_glob_pattern/replacement_text} # non greedy
${param//search_glob_pattern/replacement_text} # greedy
# Substition at left edge:
${param/#search_glob_pattern/replacement_text} # non greedy
# Substition at right edge:
${param/%search_glob_pattern/replacement_text} # non greedy

# Arrays:
# init array with elements
array=(zero one "two three")
# add an element to an array
array+=("four and beyound")
# replace space with underscore in array elements
array=("${array[@]// /_}")
# recreate array with elements from index 2 to 4
array=("${array[@]:2:3}")

# Interactive search up history for command
<CTRL>-R
# Run last command in history that starts with string
!string
# Puts last command in history that starts with string as last entry in history
!string:p

# Special parameters

# argument list
$@ or $* -- act different when in quotes. $* uses first IFS char for separation
# number of elements in argument list
$#
# shell interactive flags
$-
# shell that is currently being used
$0
# process id
$$
# process id of most recent job that occurred
$!

glob notes:
  For all nonhidden files/folders in current directory non-recursive, use -d '*'
  For all hidden files/folders in current directory non-recursive, use -d '.[^.]*'
  For all hidden and nonhidden files/folders in current directory non-recursive, use -d '* .[^.]*'

# copy contents of source to existing dir dest, including hidden stuff
# cp -a /source/. /dest/

Extra snippets:
pwsh -ExecutionPolicy [Bypass | Unrestricted | RemoteSigned| AllSigned | Default | Undefined | Restricted] -File '/path/to/script.ps1 -Flag arg'
pwsh -ExecutionPolicy [Bypass | Unrestricted | RemoteSigned| AllSigned | Default | Undefined | Restricted] -Command "& {Write-Host 'hi'}"
perl -ne 'print unless $seen{$_}++' # unique without sorting

FROM WINDOWS GIT BASH: 
################################## Construct PATH variable ##################################

#winpath=$(echo $MSYS2_WINPATH | tr ";" "\n" | sed -e 's/\\/\\\\/g' | xargs -I {} cygpath -u {})
#unixpath=''

# Set delimiter to new line
#IFS=$'\n'

#for pth in $winpath; do unixpath+=$(echo $pth)":"; done

#export PATH=$(echo $PATH:$unixpath | sed -e 's/:$//g')
#unset IFS
#unset unixpath
#unset winpath

################################# Constructed PATH variable #################################

